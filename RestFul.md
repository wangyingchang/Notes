 #### 1.场景

作为一个合格的程序员，想把RESTFUL技术讲女朋友听，并且能给她讲懂，作为我 

如果我直接回答说，“REST就是Representational State Transfer的缩写呀，翻译为中文就是‘表述性状态转移’”，那她今晚肯定得罚我跪键盘。

我必须找个合适的机会，把Restful的来龙去脉给她形象的描述一遍。 “走，咱们去楼下咖啡厅吃个下午茶吧”，我对女朋友说。 “一个芝士蛋糕，一杯拿铁，两条吸管，谢谢”，我对前台的服务员说，然后我们找了个角落坐了下来。 

 

#### Level 0 - 面向前台

“刚才我们向前台点了一杯拿铁，这个过程可以用这段文字来描述”，说着，我在纸上写下了这段JSON，虽然她不知道什么叫JSON，但理解这段文字对于英语专业8级的她，实在再简单不过。

```json
 {
   "addOrder": { 
  		"orderName": "latte" 
	}
}  
```

“我们通过这段文字，告诉前台，新增一笔订单，订单是一杯拿铁咖啡”，接着，前台给我们返回这么一串回复： 

```json
{
	"orderId": "123456"
}
```

 “订单ID？还是订单编号？” 

“恩恩，就是订单编号” 

“那我们就等着前台喊‘订单123456的客户可以取餐了’，然后就可以开吃了！”

 “哈哈，你真聪明，不过，在这之前，假设我们有一张会员卡，我们想查询一下这张会员卡的余额，这时候，要向前台发起另一个询问”，我继续在纸上写着：

```json
 {
 	"queryBalance": {
 		"cardId": "886333" 
	}
}
```

 “查询卡号为886333的卡的余额？”

 “真棒！接着，查询的结果返回来了” 

```json
{     
 "balance": "0" 
}
```

 “切，没钱……” 

“哈哈，没钱，现在我们要跟前台说，这杯咖啡不要了”，我在纸上写到： 	

```json
{
	 "deleteOrder": { 
		"orderId": "123456"
 	}
 }
```

“哼，这就把订单取消啦？”

#### Level 1 - 面向资源 

现在这家咖啡店越做越大，来喝咖啡的人越来越多，单靠前台显然是不行的，店主决定进行分工，每个资源都有专人负责，我们可以直接面向资源操作。

” “面向资源？”

 “是的，比如还是下单，请求的内容不变，但是我们多了一条消息”，

我在纸上画出这次的模型： 

```json
/orders
{
    "addOrder": {
        "orderName": "latte"
    }
}

```

多了一个斜杠和orders？这是什么意思？” “这个表示我们这个请求是发给哪个资源的，订单是一种资源，我们可以理解为是咖啡厅专门管理订单的人，他可以帮我们处理所有有关订单的操作，包括新增订单、修改订单、取消订单等操作” 

“接着还是会返回订单的编号给我们” 

```json
{ 
    "orderId": "123456" 
} 
```

下面，我们还是要查询会员卡余额，这次请求的资源变成了

``` json
/cards

{
    "queryBalance": {
        "cardId": "886333"
    }
}
 
```

“接下来是取消订单” “这个我会”，说着，她抢走我手上的笔，在纸上写了起来

```json
/orders
{
	"deleteOrder": {
		"orderId": "123456"
	}

}
```

#### Level2 - 打上标签 

“接下来，店主还想继续优化他的咖啡厅的服务流程，他发现负责处理订单的员工，每次都要去订单内容里面看是新增订单还是删除订单，还是其他的什么操作，十分不方便，于是规定，所有新增资源的请求，都在请求上面写上大大的‘POST’，表示这是一笔新增资源的请求” 

“其他种类的请求，比如查询类的，用‘GET’表示，删除类的，用‘DELETE’表示” “还有修改类的，修改分为两种，第一种，如果这个修改，无论发送多少次，最后一次修改后的资源，总是和第一次修改后的一样，比如将拿铁改为猫屎，那么用‘PUT’表示；第二种，如果这个修改，每次修改都会让这个资源和前一次的不一样，比如是加一杯咖啡，那么这种请求用‘PATCH’或者‘POST’表示”。

 “来，我们再来重复上面那个过程，来一杯拿铁”，边说边画着：

```json
POST /orders
{
	"orderName": "latte"
}
```

 请求的内容简洁多啦，不用告诉店员是addOrder，看到POST就知道是新增”，她听的很认真，理解的也很透彻。 “恩恩，返回的内容还是一样”

```json
 { 
 	"orderId": "123456"
 }
```

 “接着是查询会员卡余额，这次也简化了很多”

```json
GET /cards
{
	"cardId": "886333"
}
```

 这个请求我们还可以进一步优化为这样” 

```json
GET /cards/886333 
```

 直接把要查询的卡号写在后面了” 

“没错，接着，取消订单” 

```json
DELETE /orders/123456 
```

#### Level 3 - 完美服务

 “忽然有一天，有个顾客抱怨说，他买了咖啡后，不知道要怎么取消订单，咖啡厅一个店员回了一句，你不会看我们的宣传单吗，上面不写着：

 DELETE /orders/{orderId} 

 顾客反问道，谁会去看那个啊，店员不服...， "

"“有了这次教训，店长决定，顾客下了单之后，不仅给他们返回订单的编号，还给顾客返回所有可以对这个订单做的操作，比如告诉用户如何删除订单。

现在，我们还是发出请求，请求内容和上一次一样” 

```json
POST /orders
{
	"orderName": "latte"

}
```

 但是这次返回时多了些内容

```json
{
    "orderId": "123456",
    "link": {
        "rel": "cancel",
        "url": "/order/123456"
	}
}
```

这次返回时多了一项link信息，里面包含了一个rel属性和url属性，rel是relationship的意思，这里的关系是cancel，url则告诉你如何执行这个cancel操作，

接着你就可以这样子来取消订单啦”

```json
 DELETE /orders/123456 
```

 “订单123456的客户可以取餐了” 



#### 2.RESTFUL

##### 2.1什么是RESTFUL？

简单的说：RESTful是一种架构的规范与约束、原则，符合这种规范的架构就是RESTFUL架构。

REST是什么意思，英文Representational state transfer表述性状态转移其实就是对《资源》的表述性状态转移。

资源的地址在web中就是URL（统一资源标识符）

资源是REST系统的核心概念。 

所有的设计都是以资源为中心。

##### 2.2协议

API与用户的通信协议，总是使用HTTP协议

##### 2.3域名

应该尽量将API部署在专用域名之下。

```
 https://api.example.com
```

如果确定API很简单，不会有进一步扩展，可以考虑放在主域名下。

```
https://example.org/api/
```

##### 2.4版本（Versioning）

应该将API的版本号放入URL。

```javascript
https://api.example.com/v1/
```

另一种做法是，将版本号放在HTTP头信息中，但不如放入URL方便和直观。[Github](https://developer.github.com/v3/media/#request-specific-version)采用这种做法。

##### 2.5路径（Endpoint）

路径又称"终点"（endpoint），表示API的具体网址。
在RESTful架构中，每个网址代表一种资源（resource），所以网址中不能有动词，只能有名词，而且所用的名词往往与数据库的表格名对应。
一般来说，数据库中的表都是同种记录的"集合"（collection），所以API中的名词也应该使用复数。
举例来说，有一个API提供动物园（zoo）的信息，还包括各种动物和雇员的信息，则它的路径应该设计成下面这样。
~~~
https://api.example.com/v1/zoos
https://api.example.com/v1/animals
https://api.example.com/v1/employees
~~~

##### 2.6HTTP动词

对于资源的具体操作类型，由HTTP动词表示。

常用的HTTP动词有下面五个（括号里是对应的SQL命令）。

> - GET（SELECT）：从服务器取出资源（一项或多项）。
> - POST（CREATE）：在服务器新建一个资源。
> - PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源,与PATCH比较一般使用这个）。
> - DELETE（DELETE）：从服务器删除资源。
> - PATCH（UPDATE）：在服务器更新资源（客户端提供改变的属性）。

还有两个不常用的HTTP动词。

> - HEAD：获取资源的元数据。
> - OPTIONS：获取信息，关于资源的哪些属性是客户端可以改变的。

下面是一些例子。

> - GET /zoos：列出所有动物园
> - POST /zoos：新建一个动物园
> - GET /zoos/ID：获取某个指定动物园的信息
> - PUT /zoos/ID：更新某个指定动物园的信息（提供该动物园的全部信息）
> - PATCH /zoos/ID：更新某个指定动物园的信息（提供该动物园的部分信息）
> - DELETE /zoos/ID：删除某个动物园
> - GET /zoos/ID/animals：列出某个指定动物园的所有动物
> - DELETE /zoos/ID/animals/ID：删除某个指定动物园的指定动物

##### 2.7过滤信息（Filtering）

如果记录数量很多，服务器不可能都将它们返回给用户。API应该提供参数，过滤返回结果。

下面是一些常见的参数。

> - ?limit=10：指定返回记录的数量。
> - ?offset=10：指定返回记录的开始位置。
> - ?page=2&per_page=100：指定第几页，以及每页的记录数。
> - ?sortby=name&order=asc：指定返回结果按照哪个属性排序，以及排序顺序。
> - ?animal_type_id=1：指定筛选条件

参数的设计允许存在冗余，即允许API路径和URL参数偶尔有重复。比如，GET /zoo/ID/animals 与 GET /animals?zoo_id=ID 的含义是相同的。 

#### 2.8返回结果

针对不同操作，服务器向用户返回的结果应该符合以下规范。

> - GET /collection：返回资源对象的列表（数组）
> - GET /collection/resource：返回单个资源对象
> - POST /collection：返回新生成的资源对象
> - PUT /collection/resource：返回完整的资源对象
> - PATCH /collection/resource：返回完整的资源对象
> - DELETE /collection/resource：返回一个空文档
